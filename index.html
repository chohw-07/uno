<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>UNO</title>
  <!-- SimplePeer ë¼ì´ë¸ŒëŸ¬ë¦¬ (CDN) -->
  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <style>
    /* ê¸°ë³¸ ë°°ê²½ ë° í…ìŠ¤íŠ¸ */
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(ellipse at center, #0b6623 0%, #004d23 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #ecf0f1;
      overflow-x: hidden;
    }
    h1 { text-align: center; margin: 20px 0; }
    /* ë©”ì¸ ë©”ë‰´: ë‚˜ë¬´ í…Œì´ë¸” ëŠë‚Œ */
    #menuScreen {
      background: linear-gradient(135deg, #8B5A2B, #A0522D);
      padding: 40px;
      border: 5px solid #5D3A1A;
      border-radius: 10px;
      max-width: 500px;
      margin: 60px auto;
      box-shadow: 0 0 20px rgba(0,0,0,0.6);
      text-align: center;
    }
    #menuScreen button {
      padding: 10px 20px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      background: #27ae60;
      color: #fff;
      cursor: pointer;
      margin: 5px;
    }
    #menuScreen button:hover { background: #1e8449; }
    /* ì‹œê·¸ë„ë§ íŒ¨ë„ */
    #signalPanel {
      display: none;
      max-width: 800px;
      margin: 20px auto;
      padding: 20px;
      background: rgba(0,0,0,0.5);
      border-radius: 8px;
      text-align: center;
    }
    #signalPanel textarea {
      width: 90%;
      height: 100px;
      margin: 10px 0;
    }
    /* ê²Œì„ ì»¨í…Œì´ë„ˆ */
    #gameContainer {
      display: none;
      max-width: 1000px;
      height: 100vh;
      box-sizing: border-box;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    /* í•¸ë“œ ì˜ì—­: ìƒëŒ€ëŠ” ì¹´ë“œ ìˆ˜ë§Œ í‘œì‹œ, ë‚´ íŒ¨ëŠ” ê²¹ì¹¨ íš¨ê³¼ */
    .hand {
      position: relative;
      height: 140px;
      margin: 0 auto;
      width: 100%;
      max-width: 900px;
    }
    #opponentInfo {
      text-align: center;
      margin: 10px;
      font-size: 18px;
    }
    /* ì¤‘ì•™ í…Œì´ë¸”: ë“œë¡œìš°/ë²„ë¦¼ íŒŒì¼ */
    #table {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 50px;
      position: relative;
      margin: 20px 0;
    }
    #drawPile, #discardPile {
      position: relative;
      width: 70px;
      height: 100px;
    }
    /* ì¹´ë“œ ìŠ¤íƒ€ì¼ (UNO ì¹´ë“œ ëŠë‚Œ) */
    .card {
      width: 70px;
      height: 100px;
      border-radius: 8px;
      position: absolute;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.5);
      background: linear-gradient(to bottom, #fff, #ddd);
      border: 2px solid #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 24px;
      cursor: pointer;
      user-select: none;
      transition: transform 0.3s ease;
    }
    .card:hover { transform: translateY(-8px); }
    /* ìƒ‰ìƒë³„ ì¹´ë“œ */
    .red { border-color: #e74c3c; background: linear-gradient(to bottom, #ffcccc, #f1a9a0); }
    .yellow { border-color: #f1c40f; background: linear-gradient(to bottom, #ffffcc, #f9e79f); color: #000; }
    .green { border-color: #27ae60; background: linear-gradient(to bottom, #d4efdf, #7dcea0); }
    .blue { border-color: #3498db; background: linear-gradient(to bottom, #d6eaf8, #85c1e9); }
    .wild { border-color: #8e44ad; background: linear-gradient(to bottom, #e8daef, #d2b4de); }
    /* ë“œë¡œìš°/ë²„ë¦¼ íŒŒì¼ ì¹´ë“œ: ê³ ì • ìœ„ì¹˜ */
    #drawPile .card, #discardPile .card { position: relative; left: 0; top: 0; cursor: default; }
    /* ì¹´ë“œ ì´ë™ ì• ë‹ˆë©”ì´ì…˜ */
    .play-animation {
      animation: playCardAnim 0.5s ease-out;
    }
    @keyframes playCardAnim {
      0% { transform: scale(1) rotate(0deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(10deg); opacity: 1; }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    /* í† ìŠ¤íŠ¸ ë©”ì‹œì§€ */
    #toastContainer {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
    }
    .toast {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      margin-bottom: 10px;
      border-radius: 5px;
      color: #fff;
      font-size: 16px;
      animation: fadeInOut 3s forwards;
    }
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateY(-20px); }
      10% { opacity: 1; transform: translateY(0); }
      90% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-20px); }
    }
    /* ì¤‘ì•™ ë©”ì‹œì§€ */
    #message {
      font-size: 22px;
      margin: 10px auto;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>ìš°ë…¸ ê²Œì„</h1>
  <!-- ì´ˆê¸° ë©”ë‰´ (ì—­í•  ì„ íƒ) -->
  <div id="menuScreen">
    <p>ë‹¹ì‹ ì˜ ì—­í• ì„ ì„ íƒí•˜ì„¸ìš”.</p>
    <button id="hostBtn">í˜¸ìŠ¤íŠ¸ (ë”œëŸ¬)</button>
    <button id="clientBtn">í´ë¼ì´ì–¸íŠ¸</button>
  </div>
  <!-- ì‹œê·¸ë„ë§ íŒ¨ë„ (ìˆ˜ë™ ì‹œê·¸ë„ë§) -->
  <div id="signalPanel">
    <div id="signalInstructions"></div>
    <textarea id="signalData" placeholder="ì‹œê·¸ë„ ë°ì´í„°ë¥¼ ì—¬ê¸°ì— ë³µì‚¬í•˜ì„¸ìš”"></textarea>
    <br>
    <button id="sendSignalBtn">ì „ì†¡</button>
  </div>
  <!-- ê²Œì„ ì»¨í…Œì´ë„ˆ -->
  <div id="gameContainer">
    <div id="opponentInfo"></div>
    <div id="table">
      <div id="drawPile"></div>
      <div id="discardPile"></div>
    </div>
    <div id="message"></div>
    <div id="playerHand" class="hand"></div>
  </div>
  <!-- í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ì»¨í…Œì´ë„ˆ -->
  <div id="toastContainer"></div>
  
  <script>
    /* ========== P2P ì—°ê²° ë° ì‹œê·¸ë„ë§ ê´€ë ¨ ========= */
    let peer = null;
    let isHost = false; // í˜¸ìŠ¤íŠ¸ ì—¬ë¶€
    let connectionEstablished = false;
    const menuScreen = document.getElementById("menuScreen");
    const signalPanel = document.getElementById("signalPanel");
    const signalInstructions = document.getElementById("signalInstructions");
    const signalData = document.getElementById("signalData");
    const sendSignalBtn = document.getElementById("sendSignalBtn");
    const gameContainer = document.getElementById("gameContainer");

    document.getElementById("hostBtn").addEventListener("click", () => {
      isHost = true;
      startPeer();
      menuScreen.style.display = "none";
      signalPanel.style.display = "block";
      signalInstructions.innerText = "í˜¸ìŠ¤íŠ¸: ìƒì„±ëœ offer ë°ì´í„°ë¥¼ ë³µì‚¬í•´ì„œ ìƒëŒ€ì—ê²Œ ì „ë‹¬í•˜ì„¸ìš”.";
    });

    document.getElementById("clientBtn").addEventListener("click", () => {
      isHost = false;
      startPeer();
      menuScreen.style.display = "none";
      signalPanel.style.display = "block";
      signalInstructions.innerText = "í´ë¼ì´ì–¸íŠ¸: í˜¸ìŠ¤íŠ¸ì˜ offer ë°ì´í„°ë¥¼ ì•„ë˜ì— ë¶™ì—¬ë„£ê³  'ì „ì†¡'ì„ ëˆ„ë¥´ì„¸ìš”.";
    });

    function startPeer() {
      peer = new SimplePeer({
        initiator: isHost,
        trickle: false
      });
      peer.on('signal', data => {
        // signal ì´ë²¤íŠ¸ ë°œìƒì‹œ ì‹œê·¸ë„ ë°ì´í„°ë¥¼ í‘œì‹œ
        signalData.value = JSON.stringify(data);
      });
      peer.on('connect', () => {
        connectionEstablished = true;
        signalPanel.style.display = "none";
        initGame(); // ì—°ê²° ì™„ë£Œ í›„ ê²Œì„ ì´ˆê¸°í™”
      });
      peer.on('data', data => {
        handleMessage(JSON.parse(data));
      });
    }

    sendSignalBtn.addEventListener("click", () => {
      try {
        const receivedSignal = JSON.parse(signalData.value);
        peer.signal(receivedSignal);
        signalData.value = "";
        // í´ë¼ì´ì–¸íŠ¸ì¸ ê²½ìš°, signalInstructions ì—…ë°ì´íŠ¸
        if (!isHost) {
          signalInstructions.innerText = "ì‹œê·¸ë„ ë°ì´í„°ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤. ì—°ê²° ëŒ€ê¸°ì¤‘...";
        } else {
          signalInstructions.innerText = "ë‹µë³€ ë°ì´í„°ë¥¼ ë°›ì•„ì£¼ì„¸ìš”.";
        }
      } catch (e) {
        showToast("ì˜¬ë°”ë¥¸ ì‹œê·¸ë„ ë°ì´í„°ê°€ ì•„ë‹™ë‹ˆë‹¤!");
      }
    });
    
    /* ========== ê²Œì„ ë¡œì§ ========== */
    // UNO ì¹´ë“œ ê´€ë ¨ ë°ì´í„° ë° ìƒíƒœ ë³€ìˆ˜
    const colors = ["red", "yellow", "green", "blue"];
    const numbers = ["0","1","2","3","4","5","6","7","8","9"];
    const specialTypes = ["skip", "reverse", "draw2"];
    let deck = [];
    let discardPile = [];
    let myHand = [];
    let opponentCardCount = 0;
    let currentTurn = "host"; // í˜¸ìŠ¤íŠ¸ê°€ ì‹œì‘
    let gameStarted = false;

    // ì‚¬ìš´ë“œ íš¨ê³¼ (ì¹´ë“œ ë†“ê¸°)
    const cardSound = new Audio("data:audio/wav;base64,UklGRjQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YRAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg");

    // ì¹´ë“œ ì•„ì´ì½˜ (ìˆ«ìëŠ” ê·¸ëŒ€ë¡œ, íŠ¹ìˆ˜/ì™€ì¼ë“œ ì¹´ë“œì— ì•„ì´ì½˜ ì ìš©)
    function getCardIcon(card) {
      if(card.type === "number") return card.value;
      if(card.type === "special") {
        if(card.value === "skip") return "ğŸš«";
        if(card.value === "reverse") return "ğŸ”„";
        if(card.value === "draw2") return "ï¼‹2";
      }
      if(card.type === "wild") {
        if(card.value === "wild") return "â˜…";
        if(card.value === "draw4") return "ï¼‹4";
      }
      return card.value;
    }

    // ë± ìƒì„± (UNO ê¸°ë³¸ ì¹´ë“œ êµ¬ì„±)
    function createDeck() {
      deck = [];
      colors.forEach(color => {
        deck.push({color, value:"0", type:"number"});
        numbers.slice(1).forEach(num => {
          deck.push({color, value: num, type:"number"});
          deck.push({color, value: num, type:"number"});
        });
        specialTypes.forEach(special => {
          deck.push({color, value: special, type:"special"});
          deck.push({color, value: special, type:"special"});
        });
      });
      for(let i=0;i<4;i++){
        deck.push({color:"wild", value:"wild", type:"wild"});
        deck.push({color:"wild", value:"draw4", type:"wild"});
      }
    }

    // ë± ì„ê¸° (Fisher-Yates)
    function shuffle(array) {
      for(let i=array.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // í˜¸ìŠ¤íŠ¸ê°€ ê²Œì„ ì‹œì‘ ì‹œ: ë± ìƒì„±, ì„ê¸°, ì¹´ë“œ ë¶„ë°° (ê° 7ì¥) ë° ì˜¤í”ˆ ì¹´ë“œ ì„¤ì •
    function startNewGame() {
      createDeck();
      deck = shuffle(deck);
      myHand = deck.splice(0,7);
      // ìƒëŒ€ë°© ì¹´ë“œë„ 7ì¥ (í˜¸ìŠ¤íŠ¸ë§Œ ê´€ë¦¬í•˜ë©° ìƒëŒ€ì—ê²ŒëŠ” ì¹´ë“œ ìˆ˜ë§Œ ì „ë‹¬)
      opponentCardCount = 7;
      let firstCard = deck.shift();
      // ì²« ì¹´ë“œëŠ” ì™€ì¼ë“œê°€ ì•„ë‹ˆê²Œ
      while(firstCard.type === "wild"){
        deck.push(firstCard);
        firstCard = deck.shift();
      }
      discardPile = [firstCard];
      currentTurn = "host"; // í˜¸ìŠ¤íŠ¸ë¶€í„° ì‹œì‘
      gameStarted = true;
      sendGameState();
      renderGame();
    }

    // ê²Œì„ ìƒíƒœë¥¼ JSON ë©”ì‹œì§€ë¡œ ë³´ë‚´ê¸° (í˜¸ìŠ¤íŠ¸ ì „ìš©)
    function sendGameState() {
      if(!isHost) return;
      const state = {
        type: "update",
        publicState: {
          topCard: discardPile[discardPile.length-1],
          drawCount: deck.length,
          opponentCardCount: opponentCardCount,
          currentTurn: currentTurn
        }
      };
      peer.send(JSON.stringify(state));
    }

    // ë©”ì‹œì§€ ì²˜ë¦¬ (í˜¸ìŠ¤íŠ¸ì™€ í´ë¼ì´ì–¸íŠ¸ ëª¨ë‘)
    function handleMessage(msg) {
      if(msg.type === "update") {
        // í´ë¼ì´ì–¸íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ê°€ ë³´ë‚¸ ì—…ë°ì´íŠ¸ ìˆ˜ì‹ 
        updatePublicState(msg.publicState);
        renderGame();
      } else if(msg.type === "move") {
        // ìƒëŒ€ë°©ì˜ ì›€ì§ì„ (í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš°, í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­)
        if(isHost) {
          processOpponentMove(msg.move);
        }
      }
    }

    // í´ë¼ì´ì–¸íŠ¸ìš©: ê³µê°œ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë‚´ê°€ ë³¼ ìˆ˜ ìˆëŠ” ì •ë³´)
    let publicState = {};
    function updatePublicState(state) {
      publicState = state;
      currentTurn = state.currentTurn;
    }

    /* ========== UI ë Œë”ë§ ========== */
    // ìƒëŒ€ ì •ë³´ (ì¹´ë“œ ìˆ˜ë§Œ í‘œì‹œ)
    function renderOpponentInfo() {
      const oppDiv = document.getElementById("opponentInfo");
      oppDiv.innerText = "ìƒëŒ€ ì¹´ë“œ: " + (isHost ? opponentCardCount : publicState.opponentCardCount) + "ì¥";
    }

    // ë‚´ í•¸ë“œ ë Œë”ë§ (ê²¹ì³ì„œ ë°°ì¹˜)
    function renderHand() {
      const container = document.getElementById("playerHand");
      container.innerHTML = "";
      const containerWidth = container.clientWidth || 900;
      const cardWidth = 70;
      let offset = 0;
      if(myHand.length > 1) {
        offset = Math.min(40, (containerWidth - cardWidth) / (myHand.length - 1));
      }
      myHand.forEach((card, i) => {
        const cardDiv = document.createElement("div");
        cardDiv.className = "card " + card.color;
        cardDiv.style.left = (i*offset)+"px";
        cardDiv.innerText = getCardIcon(card);
        // ë‚´ê°€ ì°¨ë¡€ì¼ ë•Œë§Œ ì¹´ë“œ í´ë¦­ í—ˆìš©
        if((isHost && currentTurn==="host") || (!isHost && currentTurn==="client")){
          cardDiv.onclick = (e)=> playerPlay(e, i);
        }
        container.appendChild(cardDiv);
      });
    }

    // ì¤‘ì•™ í…Œì´ë¸” ë Œë”ë§ (ë“œë¡œìš°, ë²„ë¦¼ íŒŒì¼)
    function renderTable() {
      const drawDiv = document.getElementById("drawPile");
      const discardDiv = document.getElementById("discardPile");
      drawDiv.innerHTML = "";
      discardDiv.innerHTML = "";
      // ë“œë¡œìš° íŒŒì¼
      const drawCard = document.createElement("div");
      drawCard.className = "card";
      drawCard.style.position = "relative";
      drawCard.style.cursor = ( (isHost && currentTurn==="host") || (!isHost && currentTurn==="client") ) ? "pointer" : "default";
      drawCard.innerText = "ë“œë¡œìš°\n(" + (isHost ? deck.length : publicState.drawCount) + ")";
      drawCard.onclick = ()=> {
        if((isHost && currentTurn==="host") || (!isHost && currentTurn==="client")){
          playerDraw();
        }
      };
      drawDiv.appendChild(drawCard);
      // ë²„ë¦¼ íŒŒì¼ (ê°€ì¥ ìœ„ì˜ ì¹´ë“œ)
      const topCard = discardPile[discardPile.length-1];
      const topDiv = document.createElement("div");
      topDiv.className = "card " + topCard.color;
      topDiv.style.position = "relative";
      topDiv.innerText = getCardIcon(topCard);
      topDiv.classList.add("play-animation");
      discardDiv.appendChild(topDiv);
    }

    function renderGame() {
      renderOpponentInfo();
      renderHand();
      renderTable();
      document.getElementById("message").innerText = ( (isHost && currentTurn==="host") || (!isHost && currentTurn==="client") ) ? "ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤." : "ìƒëŒ€ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.";
    }

    // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í•¨ìˆ˜
    function showToast(message) {
      const container = document.getElementById("toastContainer");
      const toast = document.createElement("div");
      toast.className = "toast";
      toast.innerText = message;
      container.appendChild(toast);
      setTimeout(()=> toast.remove(), 3000);
    }

    /* ========== ê²Œì„ í”Œë ˆì´ ë¡œì§ ========== */
    // í”Œë ˆì´ì–´ê°€ ì¹´ë“œë¥¼ ë‚´ë©´ í˜¸ì¶œ (í˜¸ìŠ¤íŠ¸ì™€ í´ë¼ì´ì–¸íŠ¸ ëª¨ë‘)
    function playerPlay(e, index) {
      if( !(((isHost && currentTurn==="host") || (!isHost && currentTurn==="client"))) ) return;
      const chosenCard = myHand[index];
      if(isPlayable(chosenCard)) {
        // ì¹´ë“œ ì´ë™ ì• ë‹ˆë©”ì´ì…˜
        animateCardMove(e.currentTarget, ()=>{
          playCard(chosenCard, isHost ? "host" : "client");
          myHand.splice(index, 1);
          cardSound.play();
          if(isHost){
            // í˜¸ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸: ì§„í–‰ ìƒëŒ€ ì¹´ë“œ ìˆ˜ ë³€í™”(ì˜ˆ: draw íš¨ê³¼) ë“±
            nextTurn();
            sendGameState();
            renderGame();
          } else {
            // í´ë¼ì´ì–¸íŠ¸: ìì‹ ì˜ ì›€ì§ì„ì„ í˜¸ìŠ¤íŠ¸ì—ê²Œ ì „ë‹¬
            peer.send(JSON.stringify({type:"move", move:{card: chosenCard}}));
          }
        });
      } else {
        showToast("ì´ ì¹´ë“œëŠ” ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
      }
    }

    // í”Œë ˆì´ì–´ê°€ ë“œë¡œìš° ë²„íŠ¼ í´ë¦­ ì‹œ ì²˜ë¦¬
    function playerDraw() {
      if(!(((isHost && currentTurn==="host") || (!isHost && currentTurn==="client"))) ) return;
      if(deck.length === 0) reshuffleDeck();
      const drawn = deck.shift();
      if(isHost){
        myHand.push(drawn);
        // ë§Œì•½ ë“œë¡œìš° í›„ ë‚¼ ì¹´ë“œê°€ ì—†ìœ¼ë©´ í„´ ì¢…ë£Œ
        nextTurn();
        sendGameState();
        renderGame();
      } else {
        peer.send(JSON.stringify({type:"move", move:{draw:true}}));
      }
    }

    // í˜¸ìŠ¤íŠ¸ìš©: í´ë¼ì´ì–¸íŠ¸ì˜ ì›€ì§ì„ ì²˜ë¦¬
    function processOpponentMove(move) {
      if(move.draw) {
        // ìƒëŒ€ê°€ ë“œë¡œìš°í•¨: í´ë¼ì´ì–¸íŠ¸ì˜ íŒ¨ ì¦ê°€
        opponentCardCount++;
      } else if(move.card) {
        // ìƒëŒ€ê°€ ì¹´ë“œë¥¼ ëƒ„: í˜¸ìŠ¤íŠ¸ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì˜ íŒ¨ ìˆ˜ ê°ì†Œ
        if(opponentCardCount>0) opponentCardCount--;
        // ë²„ë¦¼ íŒŒì¼ ì—…ë°ì´íŠ¸
        discardPile.push(move.card);
        // íŠ¹ìˆ˜ ì¹´ë“œ íš¨ê³¼ ì²˜ë¦¬ (í˜¸ìŠ¤íŠ¸ ì¸¡ì—ì„œ ì²˜ë¦¬)
        processCardEffect(move.card, "client");
      }
      nextTurn();
      sendGameState();
      renderGame();
    }

    // ì¹´ë“œ í”Œë ˆì´ ì‹œ íš¨ê³¼ ì²˜ë¦¬ (í˜¸ìŠ¤íŠ¸ê°€ ê´€ë¦¬)
    function playCard(card, player) {
      // ì™€ì¼ë“œ ì¹´ë“œ: ìƒ‰ìƒ ì„ íƒ
      if(card.type === "wild") {
        let chosenColor = prompt("ì›í•˜ëŠ” ìƒ‰ìƒì„ ì…ë ¥í•˜ì„¸ìš” (red, yellow, green, blue)").toLowerCase();
        if(!colors.includes(chosenColor)){
          chosenColor = colors[Math.floor(Math.random()*4)];
          showToast("ì˜ëª»ëœ ìƒ‰ìƒ ì„ íƒ, ë¬´ì‘ìœ„ ìƒ‰ìƒìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.");
        }
        card.chosenColor = chosenColor;
        card.color = chosenColor;
      }
      discardPile.push(card);
      processCardEffect(card, player);
    }

    // ì¹´ë“œ íš¨ê³¼ ì²˜ë¦¬ (skip, reverse, draw2, draw4 ë“±)
    function processCardEffect(card, player) {
      if(card.value === "skip" || card.value === "reverse") {
        // 2ì¸ ê²Œì„ì—ì„œëŠ” reverseëŠ” skipê³¼ ë™ì¼
        // í„´ ê±´ë„ˆë›°ê¸° íš¨ê³¼: ê·¸ëƒ¥ í„´ ë„˜ê¹€
      } else if(card.value === "draw2") {
        for(let i=0;i<2;i++){
          if(deck.length===0) reshuffleDeck();
          if(player==="host"){
            // ìƒëŒ€ê°€ ë°›ìŒ
            opponentCardCount++;
          } else {
            myHand.push(deck.shift());
          }
        }
      } else if(card.value === "draw4") {
        for(let i=0;i<4;i++){
          if(deck.length===0) reshuffleDeck();
          if(player==="host"){
            opponentCardCount++;
          } else {
            myHand.push(deck.shift());
          }
        }
        // ì™€ì¼ë“œ ë“œë¡œìš°4 ì¹´ë“œì—ë„ ìƒ‰ìƒ ì„ íƒ ì ìš© (ì´ë¯¸ ì²˜ë¦¬ë¨)
      }
    }

    // í„´ ì „í™˜
    function nextTurn() {
      currentTurn = (currentTurn==="host") ? "client" : "host";
    }

    // ë±ì´ ë¹„ì—ˆì„ ê²½ìš° ì¬êµ¬ì„± (ë²„ë¦¼ íŒŒì¼ ì œì™¸)
    function reshuffleDeck() {
      let top = discardPile.pop();
      deck = shuffle(discardPile);
      discardPile = [top];
    }

    // ì¹´ë“œ ì´ë™ ì• ë‹ˆë©”ì´ì…˜ (í´ë¦­ëœ ì¹´ë“œê°€ ì¤‘ì•™ ë²„ë¦¼ íŒŒì¼ ìœ„ì¹˜ë¡œ ì´ë™)
    function animateCardMove(cardElem, callback) {
      const startRect = cardElem.getBoundingClientRect();
      const discardElem = document.getElementById("discardPile");
      const targetRect = discardElem.getBoundingClientRect();
      const clone = cardElem.cloneNode(true);
      clone.style.position = "fixed";
      clone.style.left = startRect.left + "px";
      clone.style.top = startRect.top + "px";
      clone.style.margin = 0;
      clone.style.zIndex = 1000;
      document.body.appendChild(clone);
      const deltaX = targetRect.left + targetRect.width/2 - (startRect.left + startRect.width/2);
      const deltaY = targetRect.top + targetRect.height/2 - (startRect.top + startRect.height/2);
      clone.animate([
        { transform: "translate(0,0)", opacity: 1 },
        { transform: `translate(${deltaX}px, ${deltaY}px) scale(0.5)`, opacity: 0.5 }
      ], { duration: 500, easing: "ease-in-out" }).onfinish = () => {
        clone.remove();
        callback();
      };
    }

    /* ========== ê²Œì„ ì´ˆê¸°í™” ========== */
    function initGame() {
      // ì—°ê²°ëœ í›„ ì—­í• ì— ë”°ë¼ ê²Œì„ ì´ˆê¸°í™” (í˜¸ìŠ¤íŠ¸ëŠ” ê²Œì„ì„ ì‹œì‘í•˜ê³ , í´ë¼ì´ì–¸íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ì˜ ì—…ë°ì´íŠ¸ë¥¼ ê¸°ë‹¤ë¦¼)
      gameContainer.style.display = "flex";
      if(isHost) {
        startNewGame();
      }
    }
  </script>
</body>
</html>
